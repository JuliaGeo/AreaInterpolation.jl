import{_ as e,c as t,o as a,a6 as o}from"./chunks/framework.DdX9G6jL.js";const y=JSON.parse('{"title":"Interpolation methods","description":"","frontmatter":{},"headers":[],"relativePath":"methods.md","filePath":"methods.md","lastUpdated":null}'),s={name:"methods.md"},r=o('<h1 id="Interpolation-methods" tabindex="-1">Interpolation methods <a class="header-anchor" href="#Interpolation-methods" aria-label="Permalink to &quot;Interpolation methods {#Interpolation-methods}&quot;">​</a></h1><p><code>AreaInterpolation.jl</code> provides several methods for interpolating data across polygons.</p><h2 id="Direct-method" tabindex="-1">Direct method <a class="header-anchor" href="#Direct-method" aria-label="Permalink to &quot;Direct method {#Direct-method}&quot;">​</a></h2><h2 id="Pycnophylactic-method" tabindex="-1">Pycnophylactic method <a class="header-anchor" href="#Pycnophylactic-method" aria-label="Permalink to &quot;Pycnophylactic method {#Pycnophylactic-method}&quot;">​</a></h2><p>The whole idea is rasterizing a set of polygons with some associated value, smoothing it, then summing the values within your other set of target polygons. The difference between this and a regular Gaussian filter is that at each iteration, the value in each source polygon is preserved. This is to say that if one were to aggregate the values back to the source right after the smoothing, then one would recieve the same values as output as they would during input.</p><h2 id="Dasymetric-method" tabindex="-1">Dasymetric method <a class="header-anchor" href="#Dasymetric-method" aria-label="Permalink to &quot;Dasymetric method {#Dasymetric-method}&quot;">​</a></h2><h3 id="Raster-masks" tabindex="-1">Raster masks <a class="header-anchor" href="#Raster-masks" aria-label="Permalink to &quot;Raster masks {#Raster-masks}&quot;">​</a></h3><p>Raster masks are supported.</p><h3 id="Vector-masks" tabindex="-1">Vector masks <a class="header-anchor" href="#Vector-masks" aria-label="Permalink to &quot;Vector masks {#Vector-masks}&quot;">​</a></h3><p>Vector masks (like building footprints) are not yet supported. It&#39;s trivial to do this by two interpolations, though – first interpolate the source values to the intermediate geometries, then interpolate the intermediate geometries to the target geometries.</p><h2 id="Weighted-pycnophylactic-method" tabindex="-1">Weighted-pycnophylactic method <a class="header-anchor" href="#Weighted-pycnophylactic-method" aria-label="Permalink to &quot;Weighted-pycnophylactic method {#Weighted-pycnophylactic-method}&quot;">​</a></h2>',11),i=[r];function h(n,c,d,l,m,p){return a(),t("div",null,i)}const g=e(s,[["render",h]]);export{y as __pageData,g as default};
