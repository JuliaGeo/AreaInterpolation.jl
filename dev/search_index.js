var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = ArealInterpolation","category":"page"},{"location":"#ArealInterpolation","page":"Home","title":"ArealInterpolation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ArealInterpolation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ArealInterpolation]","category":"page"},{"location":"#ArealInterpolation.AbstractArealInterpolator","page":"Home","title":"ArealInterpolation.AbstractArealInterpolator","text":"abstract type AbstractArealInterpolator\n\nThe abstract type for all areal interpolation methods.\n\nInterface\n\nAll AbstractArealInterpolators must implement the following interface:\n\ninterpolate(interpolator::AbstractArealInterpolator, target::GI.AbstractPolygon, sources, values::Vector{Vector}, source_rtree)\n\nThis interface is not set in stone and can be changed!\n\nTODOS:     - extensive vs intensive variables (currently we act as though variables are intensive)     - weight methods (sum vs total) - just pass any arbitrary accumulator\n\n\n\n\n\n","category":"type"},{"location":"#ArealInterpolation.Dasymetric","page":"Home","title":"ArealInterpolation.Dasymetric","text":"Dasymetric(mask::Raster)\n\nDasymetric interpolation uses a mask to weight the influence of each polygon.  \n\nDepending on the choice of mask, like land-use data, this can prove to be a  more accurate interpolation than the direct or pycnophylactic methods.\n\n\n\n\n\n","category":"type"},{"location":"#ArealInterpolation.Direct","page":"Home","title":"ArealInterpolation.Direct","text":"Direct()\n\nA simple direct method for areal interpolation.  \n\nTakes the area-weighted mean of all source polygons' features,  weighted by their areas of intersection with the target polygon.\n\nThis method does not allocate a Raster, but it does perform polygon intersection tests.\n\n\n\n\n\n","category":"type"},{"location":"#ArealInterpolation.Pycnophylactic","page":"Home","title":"ArealInterpolation.Pycnophylactic","text":"Pycnophylactic()\n\nA pycnophylactic method for areal interpolation.\n\nPycnophylactic interpolation (Tobler, 1979) interpolates the source zone attribute  to the target zones in a way that avoids sharp discontinuities between neighbouring  target zones.  It assumes that no sharp boundaries exist in the distribution of the  allocated data, which may not be the case, for example, when target zones are divided  by linear features (rivers, railways, roads) or are adjacent to waterbodies. \n\nHowever, it generates intuitively elegant allocations for many urban case studies with  many applications (Kounadi, Ristea, Leitner, & Langford, 2018; Comber, Proctor, & Anthony, 2008).\n\nThis description was taken in part from the GIS&T Body of Knowledge.\n\n\n\n\n\n","category":"type"},{"location":"#ArealInterpolation.decompose_to_geoms_and_values-Tuple{Any}","page":"Home","title":"ArealInterpolation.decompose_to_geoms_and_values","text":"decompose_to_geoms_and_values(sources; features = nothing)\n\nDecompose a table or feature collection into geometries and values. Returns (geometries::Vector{Geometry}, values::NamedTuple{Vector}).  \n\nvalues is a namedtuple of each value column in sources.  A value column is something whose eltype satisfies isvaluecol, and is currently Union{Number, Missing}.\n\n\n\n\n\n","category":"method"}]
}
